<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Handwriting Quiz Master</title>
    <script src="https://unpkg.com/peerjs@1.4.7/dist/peerjs.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/qrcodejs/1.0.0/qrcode.min.js"></script>
    <style>
        body { font-family: 'Helvetica Neue', Arial, sans-serif; background: #222; color: #fff; margin: 0; padding: 20px; text-align: center; user-select: none; }
        .hidden { display: none !important; }
        
        /* Layouts */
        .screen { max-width: 1000px; margin: 0 auto; }
        
        /* Canvas (Drawing Board) */
        .canvas-container {
            position: relative;
            width: 300px; height: 200px;
            margin: 0 auto 20px auto;
            border: 4px solid #fff;
            background: #fff;
            border-radius: 10px;
            overflow: hidden;
            cursor: crosshair;
        }
        canvas { display: block; touch-action: none; } /* Stop scrolling on touch */

        /* Buttons */
        button { border: none; padding: 10px 20px; border-radius: 5px; font-size: 16px; cursor: pointer; margin: 5px; transition: 0.2s; color: #fff; }
        .btn-clear { background: #7f8c8d; }
        .btn-submit { background: #e74c3c; font-weight: bold; width: 100px; }
        .btn-submit:disabled { background: #555; cursor: not-allowed; }
        
        .btn-judge-ok { background: #e74c3c; flex: 1; margin: 2px; } /* Red */
        .btn-judge-ng { background: #3498db; flex: 1; margin: 2px; } /* Blue */
        
        /* PC Grid Display */
        #pc-grid { 
            display: grid; 
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); 
            gap: 20px; margin-top: 20px; 
        }
        .pc-card {
            background: #444; border-radius: 10px; padding: 10px;
            display: flex; flex-direction: column; align-items: center;
            transition: 0.3s; border: 4px solid #555;
        }
        .pc-card img { 
            width: 100%; height: auto; background: #fff; border-radius: 5px; 
            filter: blur(10px); transition: 0.5s; opacity: 0.5;
        }
        .pc-card.revealed img { filter: blur(0); opacity: 1; }
        
        /* Background Colors for Result */
        .bg-correct { background-color: #c0392b !important; border-color: #e74c3c !important; }
        .bg-wrong { background-color: #2980b9 !important; border-color: #3498db !important; }
        
        .player-name { font-size: 20px; font-weight: bold; margin-bottom: 10px; }
        .status-text { font-size: 14px; color: #aaa; margin-top: 5px; }

        /* Judge List */
        .judge-item {
            background: #333; padding: 10px; margin-bottom: 10px; border-radius: 8px; border: 1px solid #555;
            display: flex; flex-direction: column; align-items: center;
        }
        .judge-item img { width: 200px; background: #fff; border-radius: 4px; margin-bottom: 10px; }
        .judge-controls { display: flex; width: 100%; justify-content: space-between; }

        /* Common inputs */
        input[type="text"] { padding: 10px; border-radius: 5px; border: none; width: 80%; font-size: 16px; margin-bottom: 10px; }
    </style>
</head>
<body>

<div id="screen-pc" class="screen hidden">
    <h1 style="color:#f1c40f;">Handwriting Quiz</h1>
    <div style="text-align:right;">
        <button onclick="resetBoard()" style="background:#f39c12; color:#000;">全回答リセット</button>
    </div>
    
    <div id="pc-grid">
        </div>

    <div style="margin-top:50px; border-top:1px solid #555; padding-top:20px;">
        <p>【判定役用 QRコード】</p>
        <div id="qrcode-judge" style="background:#fff; padding:10px; display:inline-block;"></div>
        <br>
        <button onclick="showPlayerQR()" style="background:#27ae60; margin-top:10px;">参加者用QRを表示</button>
    </div>
</div>

<div id="modal-qr" class="hidden" style="position:fixed; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,0.9); z-index:999; display:flex; flex-direction:column; justify-content:center; align-items:center;">
    <h2>参加者はスマホで読み込んでください</h2>
    <div id="qrcode-player" style="background:#fff; padding:20px;"></div>
    <button onclick="document.getElementById('modal-qr').classList.add('hidden')" style="margin-top:20px; background:#7f8c8d;">閉じる</button>
</div>


<div id="screen-judge" class="screen hidden">
    <h2 style="color:#f39c12;">[判定役] 管理画面</h2>
    <p id="judge-status" style="color:#2ecc71;">PC接続済み</p>
    <hr>
    <div id="judge-list">
        <p style="color:#aaa;">回答待ち...</p>
    </div>
</div>


<div id="screen-login" class="screen hidden">
    <h1>手書きクイズ</h1>
    <input type="text" id="my-name" placeholder="ニックネーム">
    <button onclick="joinGame()" style="background:#27ae60; width:100%;">参加する</button>
</div>

<div id="screen-draw" class="screen hidden">
    <h2 id="disp-name"></h2>
    
    <div class="canvas-container">
        <canvas id="drawing-board" width="300" height="200"></canvas>
    </div>
    
    <div>
        <button class="btn-clear" onclick="clearCanvas()">消去</button>
        <button id="btn-send" class="btn-submit" onclick="sendImage()">送信</button>
    </div>
    <p id="player-status" style="color:#f1c40f; margin-top:10px; font-weight:bold;"></p>
</div>


<script>
    // --- Global Vars ---
    let peer, conn;
    let myId = null;
    let hostConn = null;
    let connections = {}; // Host: player connections
    let judgeConn = null; // Host: judge connection
    let players = {}; // { id: {name, image, status} }
    let myRole = 'player';
    
    // Canvas vars
    let canvas, ctx;
    let isDrawing = false;

    // --- Init ---
    window.onload = () => {
        const urlParams = new URLSearchParams(window.location.search);
        const hostId = urlParams.get('host');
        const role = urlParams.get('role');

        if (hostId) {
            // Client (Player or Judge)
            setupPeer(false, hostId, role);
        } else {
            // Host (PC)
            setupPeer(true);
        }
    };

    function setupPeer(isHostMode, hostId = null, role = null) {
        peer = new Peer();
        peer.on('open', (id) => {
            myId = id;
            if (isHostMode) {
                initHost();
            } else {
                if (role === 'judge') initJudge(hostId);
                else initPlayer(hostId);
            }
        });
        peer.on('error', err => alert("Error: " + err.type));
    }

    // ================= HOST (PC) LOGIC =================
    function initHost() {
        document.getElementById('screen-pc').classList.remove('hidden');
        
        // QR for Judge
        const judgeUrl = `${location.href.split('?')[0]}?host=${myId}&role=judge`;
        new QRCode(document.getElementById("qrcode-judge"), { text: judgeUrl, width: 100, height: 100 });

        // QR for Players
        const playerUrl = `${location.href.split('?')[0]}?host=${myId}`;
        new QRCode(document.getElementById("qrcode-player"), { text: playerUrl, width: 200, height: 200 });

        peer.on('connection', c => {
            c.on('open', () => {
                c.on('data', data => handleHostData(c, data));
            });
        });
    }

    function showPlayerQR() {
        document.getElementById('modal-qr').classList.remove('hidden');
    }

    function handleHostData(c, data) {
        // Judge Connected
        if (data.type === 'JUDGE_JOIN') {
            judgeConn = c;
            console.log("Judge Connected");
            // Sync current state to judge
            Object.keys(players).forEach(pid => {
                if(players[pid].image) {
                    judgeConn.send({
                        type: 'NEW_ANSWER',
                        id: pid,
                        name: players[pid].name,
                        image: players[pid].image
                    });
                }
            });
        }
        // Player Join
        else if (data.type === 'PLAYER_JOIN') {
            connections[c.peer] = c;
            players[c.peer] = { name: data.name, image: null, status: 'waiting' };
            renderPcGrid();
        }
        // Player Image Received
        else if (data.type === 'SUBMIT_IMAGE') {
            players[c.peer].image = data.image;
            players[c.peer].status = 'received'; // Received but hidden
            renderPcGrid();
            
            // Send to Judge
            if (judgeConn) {
                judgeConn.send({
                    type: 'NEW_ANSWER',
                    id: c.peer,
                    name: players[c.peer].name,
                    image: data.image
                });
            }
        }
        // Judge Decision
        else if (data.type === 'JUDGE_DECISION') {
            const pId = data.targetId;
            if (players[pId]) {
                players[pId].status = data.result; // 'correct' or 'wrong'
                renderPcGrid();
            }
        }
    }

    function renderPcGrid() {
        const grid = document.getElementById('pc-grid');
        grid.innerHTML = "";
        
        Object.keys(players).forEach(id => {
            const p = players[id];
            const div = document.createElement('div');
            
            // Class management for background color
            let cardClass = "pc-card";
            let statusLabel = "回答待ち...";
            
            if (p.status === 'received') {
                statusLabel = "回答 受信済み";
            } else if (p.status === 'correct') {
                cardClass += " bg-correct revealed";
                statusLabel = "正解！！";
            } else if (p.status === 'wrong') {
                cardClass += " bg-wrong revealed";
                statusLabel = "不正解...";
            }

            // Image tag (placeholder or real)
            let imgTag = "";
            if (p.image) {
                imgTag = `<img src="${p.image}">`;
            } else {
                imgTag = `<div style="width:100%; height:150px; background:#333; display:flex; align-items:center; justify-content:center; color:#555;">未回答</div>`;
            }

            div.className = cardClass;
            div.innerHTML = `
                <div class="player-name">${p.name}</div>
                ${imgTag}
                <div class="status-text">${statusLabel}</div>
            `;
            grid.appendChild(div);
        });
    }

    function resetBoard() {
        if(!confirm("全員の回答をリセットしますか？")) return;
        
        Object.keys(players).forEach(id => {
            players[id].image = null;
            players[id].status = 'waiting';
            if(connections[id]) connections[id].send({ type: 'RESET' });
        });
        renderPcGrid();
        if(judgeConn) judgeConn.send({ type: 'RESET_ALL' });
    }

    // ================= JUDGE LOGIC =================
    function initJudge(hostId) {
        document.getElementById('screen-judge').classList.remove('hidden');
        hostConn = peer.connect(hostId);
        
        hostConn.on('open', () => {
            hostConn.send({ type: 'JUDGE_JOIN' });
        });
        
        hostConn.on('data', data => {
            if (data.type === 'NEW_ANSWER') {
                addJudgeItem(data);
            } else if (data.type === 'RESET_ALL') {
                document.getElementById('judge-list').innerHTML = '<p style="color:#aaa;">回答待ち...</p>';
            }
        });
    }

    function addJudgeItem(data) {
        const list = document.getElementById('judge-list');
        if(list.innerHTML.includes('回答待ち')) list.innerHTML = "";
        
        // Avoid duplicates
        if(document.getElementById(`judge-${data.id}`)) return;

        const div = document.createElement('div');
        div.id = `judge-${data.id}`;
        div.className = 'judge-item';
        div.innerHTML = `
            <div style="font-weight:bold; margin-bottom:5px;">${data.name}</div>
            <img src="${data.image}">
            <div class="judge-controls">
                <button class="btn-judge-ok" onclick="sendDecision('${data.id}', 'correct', this)">正解 (赤)</button>
                <button class="btn-judge-ng" onclick="sendDecision('${data.id}', 'wrong', this)">不正解 (青)</button>
            </div>
        `;
        list.appendChild(div);
    }

    function sendDecision(targetId, result, btn) {
        hostConn.send({ type: 'JUDGE_DECISION', targetId: targetId, result: result });
        // Disable buttons visually
        const parent = btn.parentNode;
        parent.innerHTML = `<span style="font-weight:bold; color:${result==='correct'?'#e74c3c':'#3498db'}">判定済み: ${result==='correct'?'正解':'不正解'}</span>`;
    }

    // ================= PLAYER LOGIC =================
    function initPlayer(hostId) {
        document.getElementById('screen-login').classList.remove('hidden');
        
        // Setup Canvas
        canvas = document.getElementById('drawing-board');
        ctx = canvas.getContext('2d');
        
        // Touch events
        canvas.addEventListener('touchstart', startDraw, {passive: false});
        canvas.addEventListener('touchmove', draw, {passive: false});
        canvas.addEventListener('touchend', endDraw);
        
        // Mouse events
        canvas.addEventListener('mousedown', startDraw);
        canvas.addEventListener('mousemove', draw);
        canvas.addEventListener('mouseup', endDraw);
        canvas.addEventListener('mouseout', endDraw);

        // Connect logic
        hostConn = peer.connect(hostId);
        hostConn.on('open', () => console.log("Connected"));
        hostConn.on('data', data => {
            if (data.type === 'RESET') {
                clearCanvas();
                document.getElementById('btn-send').disabled = false;
                document.getElementById('btn-send').innerText = "送信";
                document.getElementById('player-status').innerText = "";
            }
        });
    }

    function joinGame() {
        const name = document.getElementById('my-name').value;
        if (!name) return alert("名前を入力してください");
        
        hostConn.send({ type: 'PLAYER_JOIN', name: name });
        document.getElementById('screen-login').classList.add('hidden');
        document.getElementById('screen-draw').classList.remove('hidden');
        document.getElementById('disp-name').innerText = name;
        
        // Init Canvas Style
        ctx.lineWidth = 3;
        ctx.lineCap = 'round';
        ctx.strokeStyle = '#000';
    }

    // --- Drawing Functions ---
    function getPos(e) {
        const rect = canvas.getBoundingClientRect();
        let x, y;
        if (e.touches) {
            x = e.touches[0].clientX - rect.left;
            y = e.touches[0].clientY - rect.top;
        } else {
            x = e.clientX - rect.left;
            y = e.clientY - rect.top;
        }
        return {x, y};
    }

    function startDraw(e) {
        e.preventDefault();
        isDrawing = true;
        const pos = getPos(e);
        ctx.beginPath();
        ctx.moveTo(pos.x, pos.y);
    }

    function draw(e) {
        if (!isDrawing) return;
        e.preventDefault();
        const pos = getPos(e);
        ctx.lineTo(pos.x, pos.y);
        ctx.stroke();
    }

    function endDraw() {
        isDrawing = false;
    }

    function clearCanvas() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
    }

    function sendImage() {
        const dataUrl = canvas.toDataURL('image/png');
        hostConn.send({ type: 'SUBMIT_IMAGE', image: dataUrl });
        
        const btn = document.getElementById('btn-send');
        btn.disabled = true;
        btn.innerText = "送信済み";
        document.getElementById('player-status').innerText = "判定をお待ちください...";
    }

</script>
</body>
</html>
